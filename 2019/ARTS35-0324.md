# ARTS-35 2019-03-24

- Algorithm:[700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)
- Review: [5 best libraries for making AJAX calls in React](https://hashnode.com/post/5-best-libraries-for-making-ajax-calls-in-react-cis8x5f7k0jl7th53z68s41k1)
- Tip: 二叉查找树相关的几个基本概念
- Share: [深入浅出UML类图](http://www.uml.org.cn/oobject/201211231.asp)

## Algorithm

```java
package org.nocoder.leetcode.solution;

/**
 * 700. Search in a Binary Search Tree
 * <p>
 * Given the root node of a binary search tree (BST) and a value.
 * You need to find the node in the BST that the node's value equals the given value.
 * Return the subtree rooted with that node.
 * If such node doesn't exist, you should return NULL.
 * <p>
 * For example,
 * <p>
 * Given the tree:
 * 4
 * / \
 * 2   7
 * / \
 * 1   3
 * <p>
 * And the value to search: 2
 * You should return this subtree:
 * 2
 * / \
 * 1   3
 * In the example above, if we want to search the value 5,
 * <p>
 * since there is no node with value 5, we should return NULL.
 * <p>
 * Note that an empty tree is represented by NULL,
 * <p>
 * therefore you would see the expected output (serialized tree format) as [], not null.
 *
 * @author jason
 * @date 2019/3/31.
 */
public class SearchInBinarySearchTree {

    public static void main(String[] args) {
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);
        root.right = new TreeNode(7);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(3);
        SearchInBinarySearchTree.searchBST(root, 2);
    }

    public static TreeNode searchBST(TreeNode root, int val) {
        TreeNode current = root;
        while(current != null){
            if(val < current.val){
                current = current.left;
            }else if (val > current.val){
                current = current.right;
            }else{
                current.print();
                return current;
            }
        }
        return null;
    }
}

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;


    public TreeNode(int val) {
        this.val = val;
    }

    public void print() {
        System.out.println("val: " + this.val);
        System.out.println("left: " + this.left.val);
        System.out.println("right: " + this.right.val);
    }
}
```



## Review

### [5 best libraries for making AJAX calls in React](https://hashnode.com/post/5-best-libraries-for-making-ajax-calls-in-react-cis8x5f7k0jl7th53z68s41k1)

- jQuery $.ajax
- Fetch API
- Superagent
- Axios
- Request

`fetch`作为与远程资源交互的新标准化API，建议将其用于所有AJAX需求（不仅在React中，而且在所有类型的JavaScript应用程序中）。

## Tip

### 二叉查找树相关的几个基本概念

> 做到了 leetcode 中的 [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)，就顺便把二叉查找树的基本概念复习一下

- **树（tree）**是一种典型的数据结构，提供了一种层次组织机构，数据可以存储在树中的每个结点内。

- **二叉树（binary tree）**是一种层次结构，要么是空集，要么是一个称为根（root）元素和两棵不同的二叉树组成的树，这两棵二叉树分别称为左子树和右子树。
- 一条路径的**长度（length）**是指在该条路径上的边的个数。
- 一个结点的**深度（depth）**是指从跟结点到该结点的路径长度。
- **兄弟结点（sibling）**是共享同一父结点的结点。
- 没有子结点的结点称为**叶结点（leaf）**。
- **二叉查找树（binary search tree）**是特殊类型的二叉树，没有重复元素，对于树种的每一个结点，它的左子树中的结点的值都小于该结点的值，而它的右子树的结点的值都大于该结点的值。

参考文献：[《Java语言程序设计（进阶篇）》](https://book.douban.com/subject/1879446/)

## Share

### [深入浅出UML类图](http://www.uml.org.cn/oobject/201211231.asp)

2012年的一篇文章，图文并茂的将UML类图与类与类之间的关系解释的清清楚楚，对UML类图模糊的同学，建议仔细阅读。